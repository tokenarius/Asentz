{
  "language": "Solidity",
  "sources": {
    "contracts/base/FuroStream.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IFuroStream.sol\";\n\ncontract FuroStream is\n    IFuroStream,\n    ERC721(\"Furo Stream\", \"FUROSTREAM\"),\n    Multicall,\n    BoringOwnable\n{\n    IBentoBoxMinimal public immutable bentoBox;\n    address public immutable wETH;\n\n    uint256 public streamIds;\n\n    address public tokenURIFetcher;\n\n    mapping(uint256 => Stream) public streams;\n\n    // custom errors\n    error NotSenderOrRecipient();\n    error InvalidStartTime();\n    error InvalidEndTime();\n    error InvalidWithdrawTooMuch();\n    error NotSender();\n    error Overflow();\n\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\n        bentoBox = _bentoBox;\n        wETH = _wETH;\n        streamIds = 1000;\n        _bentoBox.registerProtocol();\n    }\n\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\n        tokenURIFetcher = _fetcher;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\n    }\n\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        bentoBox.setMasterContractApproval(\n            user,\n            address(this),\n            approved,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createStream(\n        address recipient,\n        address token,\n        uint64 startTime,\n        uint64 endTime,\n        uint256 amount, /// @dev in token amount and not in shares\n        bool fromBentoBox\n    )\n        external\n        payable\n        override\n        returns (uint256 streamId, uint256 depositedShares)\n    {\n        if (startTime < block.timestamp) revert InvalidStartTime();\n        if (endTime <= startTime) revert InvalidEndTime();\n\n        depositedShares = _depositToken(\n            token,\n            msg.sender,\n            address(this),\n            amount,\n            fromBentoBox\n        );\n\n        streamId = streamIds++;\n\n        _mint(recipient, streamId);\n\n        streams[streamId] = Stream({\n            sender: msg.sender,\n            token: token == address(0) ? wETH : token,\n            depositedShares: uint128(depositedShares), // @dev safe since we know bento returns u128\n            withdrawnShares: 0,\n            startTime: startTime,\n            endTime: endTime\n        });\n\n        emit CreateStream(\n            streamId,\n            msg.sender,\n            recipient,\n            token,\n            depositedShares,\n            startTime,\n            endTime,\n            fromBentoBox\n        );\n    }\n\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 sharesToWithdraw,\n        address withdrawTo,\n        bool toBentoBox,\n        bytes calldata taskData\n    ) external override returns (uint256 recipientBalance, address to) {\n        address recipient = ownerOf[streamId];\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\n            revert NotSenderOrRecipient();\n        }\n        Stream storage stream = streams[streamId];\n        (, recipientBalance) = _streamBalanceOf(stream);\n        if (recipientBalance < sharesToWithdraw)\n            revert InvalidWithdrawTooMuch();\n        stream.withdrawnShares += uint128(sharesToWithdraw);\n\n        if (msg.sender == recipient && withdrawTo != address(0)) {\n            to = withdrawTo;\n        } else {\n            to = recipient;\n        }\n\n        _transferToken(\n            stream.token,\n            address(this),\n            to,\n            sharesToWithdraw,\n            toBentoBox\n        );\n\n        if (taskData.length != 0 && msg.sender == recipient)\n            ITasker(to).onTaskReceived(taskData);\n\n        emit Withdraw(\n            streamId,\n            sharesToWithdraw,\n            withdrawTo,\n            stream.token,\n            toBentoBox\n        );\n    }\n\n    function cancelStream(uint256 streamId, bool toBentoBox)\n        external\n        override\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        address recipient = ownerOf[streamId];\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\n            revert NotSenderOrRecipient();\n        }\n        Stream memory stream = streams[streamId];\n        (senderBalance, recipientBalance) = _streamBalanceOf(stream);\n\n        delete streams[streamId];\n\n        _transferToken(\n            stream.token,\n            address(this),\n            recipient,\n            recipientBalance,\n            toBentoBox\n        );\n        _transferToken(\n            stream.token,\n            address(this),\n            stream.sender,\n            senderBalance,\n            toBentoBox\n        );\n\n        emit CancelStream(\n            streamId,\n            senderBalance,\n            recipientBalance,\n            stream.token,\n            toBentoBox\n        );\n    }\n\n    function getStream(uint256 streamId)\n        external\n        view\n        override\n        returns (Stream memory)\n    {\n        return streams[streamId];\n    }\n\n    function streamBalanceOf(uint256 streamId)\n        external\n        view\n        override\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        return _streamBalanceOf(streams[streamId]);\n    }\n\n    function _streamBalanceOf(Stream memory stream)\n        internal\n        view\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        if (block.timestamp <= stream.startTime) {\n            senderBalance = stream.depositedShares;\n            recipientBalance = 0;\n        } else if (stream.endTime <= block.timestamp) {\n            recipientBalance = stream.depositedShares - stream.withdrawnShares;\n            senderBalance = 0;\n        } else {\n            uint64 timeDelta = uint64(block.timestamp) - stream.startTime;\n            uint128 streamed = ((stream.depositedShares * timeDelta) /\n                (stream.endTime - stream.startTime));\n            recipientBalance = streamed - stream.withdrawnShares;\n            senderBalance = stream.depositedShares - streamed;\n        }\n    }\n\n    function updateSender(uint256 streamId, address sender) external override {\n        Stream storage stream = streams[streamId];\n        if (msg.sender != stream.sender) revert NotSender();\n        stream.sender = sender;\n    }\n\n    function updateStream(\n        uint256 streamId,\n        uint128 topUpAmount,\n        uint64 extendTime,\n        bool fromBentoBox\n    ) external payable override returns (uint256 depositedShares) {\n        Stream storage stream = streams[streamId];\n        if (msg.sender != stream.sender) revert NotSender();\n\n        depositedShares = _depositToken(\n            stream.token,\n            stream.sender,\n            address(this),\n            topUpAmount,\n            fromBentoBox\n        );\n\n        address recipient = ownerOf[streamId];\n\n        (uint256 senderBalance, uint256 recipientBalance) = _streamBalanceOf(\n            stream\n        );\n\n        stream.startTime = uint64(block.timestamp);\n        stream.withdrawnShares = 0;\n        uint256 newDepositedShares = senderBalance + depositedShares;\n        if (newDepositedShares > type(uint128).max) revert Overflow();\n        stream.depositedShares = uint128(newDepositedShares);\n        stream.endTime += extendTime;\n\n        _transferToken(\n            stream.token,\n            address(this),\n            recipient,\n            recipientBalance,\n            true\n        );\n\n        emit UpdateStream(streamId, topUpAmount, extendTime, fromBentoBox);\n    }\n\n    function _depositToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bool fromBentoBox\n    ) internal returns (uint256 depositedShares) {\n        if (fromBentoBox) {\n            depositedShares = bentoBox.toShare(token, amount, false);\n            bentoBox.transfer(token, from, to, depositedShares);\n        } else {\n            (, depositedShares) = bentoBox.deposit{\n                value: token == address(0) ? amount : 0\n            }(token, from, to, amount, 0);\n        }\n    }\n\n    function _transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 share,\n        bool toBentoBox\n    ) internal {\n        if (toBentoBox) {\n            bentoBox.transfer(token, from, to, share);\n        } else {\n            bentoBox.withdraw(token, from, to, 0, share);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IFuroStream.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"./ITasker.sol\";\nimport \"./ITokenURIFetcher.sol\";\nimport \"./IBentoBoxMinimal.sol\";\nimport \"../utils/Multicall.sol\";\nimport \"../utils/BoringOwnable.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ninterface IFuroStream {\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    function createStream(\n        address recipient,\n        address token,\n        uint64 startTime,\n        uint64 endTime,\n        uint256 amount, /// @dev in token amount and not in shares\n        bool fromBento\n    ) external payable returns (uint256 streamId, uint256 depositedShares);\n\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 sharesToWithdraw,\n        address withdrawTo,\n        bool toBentoBox,\n        bytes memory taskData\n    ) external returns (uint256 recipientBalance, address to);\n\n    function cancelStream(uint256 streamId, bool toBentoBox)\n        external\n        returns (uint256 senderBalance, uint256 recipientBalance);\n\n    function updateSender(uint256 streamId, address sender) external;\n\n    function updateStream(\n        uint256 streamId,\n        uint128 topUpAmount,\n        uint64 extendTime,\n        bool fromBentoBox\n    ) external payable returns (uint256 depositedShares);\n\n    function streamBalanceOf(uint256 streamId)\n        external\n        view\n        returns (uint256 senderBalance, uint256 recipientBalance);\n\n    function getStream(uint256 streamId) external view returns (Stream memory);\n\n    event CreateStream(\n        uint256 indexed streamId,\n        address indexed sender,\n        address indexed recipient,\n        address token,\n        uint256 amount,\n        uint256 startTime,\n        uint256 endTime,\n        bool fromBentoBox\n    );\n\n    event UpdateStream(\n        uint256 indexed streamId,\n        uint128 indexed topUpAmount,\n        uint64 indexed extendTime,\n        bool fromBentoBox\n    );\n\n    event Withdraw(\n        uint256 indexed streamId,\n        uint256 indexed sharesToWithdraw,\n        address indexed withdrawTo,\n        address token,\n        bool toBentoBox\n    );\n\n    event CancelStream(\n        uint256 indexed streamId,\n        uint256 indexed senderBalance,\n        uint256 indexed recipientBalance,\n        address token,\n        bool toBentoBox\n    );\n\n    struct Stream {\n        address sender;\n        address token;\n        uint128 depositedShares;\n        uint128 withdrawnShares;\n        uint64 startTime;\n        uint64 endTime;\n    }\n}\n"
    },
    "contracts/interfaces/ITasker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\ninterface ITasker {\n    function onTaskReceived(\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITokenURIFetcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\ninterface ITokenURIFetcher {\n    function fetchTokenURIData(uint256 id)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/interfaces/IBentoBoxMinimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token_ The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall {\n    function multicall(bytes[] calldata data)\n        public\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}"
    },
    "contracts/utils/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(\n                newOwner != address(0) || renounce,\n                \"Ownable: zero address\"\n            );\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(\n            msg.sender == _pendingOwner,\n            \"Ownable: caller != pending owner\"\n        );\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IFuroVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"./ITasker.sol\";\nimport \"./IERC20.sol\";\nimport \"./ITokenURIFetcher.sol\";\nimport \"./IBentoBoxMinimal.sol\";\nimport \"../utils/Multicall.sol\";\nimport \"../utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ninterface IFuroVesting {\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    function createVesting(VestParams calldata vestParams)\n        external\n        payable\n        returns (\n            uint256 depositedShares,\n            uint256 vestId,\n            uint128 stepShares,\n            uint128 cliffShares\n        );\n\n    function withdraw(\n        uint256 vestId,\n        bytes memory taskData,\n        bool toBentoBox\n    ) external;\n\n    function stopVesting(uint256 vestId, bool toBentoBox) external;\n\n    function vestBalance(uint256 vestId) external view returns (uint256);\n\n    function updateOwner(uint256 vestId, address newOwner) external;\n\n    struct VestParams {\n        IERC20 token;\n        address recipient;\n        uint32 start;\n        uint32 cliffDuration;\n        uint32 stepDuration;\n        uint32 steps;\n        uint128 stepPercentage;\n        uint128 amount;\n        bool fromBentoBox;\n    }\n\n    struct Vest {\n        address owner;\n        IERC20 token;\n        uint32 start;\n        uint32 cliffDuration;\n        uint32 stepDuration;\n        uint32 steps;\n        uint128 cliffShares;\n        uint128 stepShares;\n        uint128 claimed;\n    }\n\n    event CreateVesting(\n        uint256 indexed vestId,\n        IERC20 token,\n        address indexed owner,\n        address indexed recipient,\n        uint32 start,\n        uint32 cliffDuration,\n        uint32 stepDuration,\n        uint32 steps,\n        uint128 cliffShares,\n        uint128 stepShares,\n        bool fromBentoBox\n    );\n\n    event Withdraw(\n        uint256 indexed vestId,\n        IERC20 indexed token,\n        uint256 indexed amount,\n        bool toBentoBox\n    );\n\n    event CancelVesting(\n        uint256 indexed vestId,\n        uint256 indexed ownerAmount,\n        uint256 indexed recipientAmount,\n        IERC20 token,\n        bool toBentoBox\n    );\n\n    event LogUpdateOwner(uint256 indexed vestId, address indexed newOwner);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x95d89b41)\n        );\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x06fdde03)\n        );\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeDecimals(IERC20 token) public view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x313ce567)\n        );\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: Transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TransferFrom failed\"\n        );\n    }\n}\n"
    },
    "contracts/mock/TaskReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/ITasker.sol\";\n\ncontract TaskReceiverMock is ITasker {\n\n    function onTaskReceived(bytes memory taskData) external override {\n        \n    }\n\n}"
    },
    "contracts/base/FuroVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IFuroVesting.sol\";\n\ncontract FuroVesting is\n    IFuroVesting,\n    ERC721(\"Furo Vesting\", \"FUROVEST\"),\n    Multicall,\n    BoringOwnable\n{\n    IBentoBoxMinimal public immutable bentoBox;\n    address public immutable wETH;\n\n    address public tokenURIFetcher;\n\n    mapping(uint256 => Vest) public vests;\n\n    uint256 public vestIds;\n\n    uint256 public constant PERCENTAGE_PRECISION = 1e18;\n\n    // custom errors\n    error InvalidStart();\n    error NotOwner();\n    error NotVestReceiver();\n    error InvalidStepSetting();\n\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\n        bentoBox = _bentoBox;\n        wETH = _wETH;\n        vestIds = 1;\n        _bentoBox.registerProtocol();\n    }\n\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\n        tokenURIFetcher = _fetcher;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\n    }\n\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        bentoBox.setMasterContractApproval(\n            user,\n            address(this),\n            approved,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createVesting(VestParams calldata vestParams)\n        external\n        payable\n        override\n        returns (\n            uint256 depositedShares,\n            uint256 vestId,\n            uint128 stepShares,\n            uint128 cliffShares\n        )\n    {\n        if (vestParams.start < block.timestamp) revert InvalidStart();\n        if (vestParams.stepPercentage > PERCENTAGE_PRECISION)\n            revert InvalidStepSetting();\n        if (vestParams.stepDuration == 0 || vestParams.steps == 0)\n            revert InvalidStepSetting();\n\n        depositedShares = _depositToken(\n            address(vestParams.token),\n            msg.sender,\n            address(this),\n            vestParams.amount,\n            vestParams.fromBentoBox\n        );\n        stepShares = uint128(\n            (vestParams.stepPercentage * depositedShares) / PERCENTAGE_PRECISION\n        );\n        cliffShares = uint128(\n            depositedShares - (stepShares * vestParams.steps)\n        );\n\n        vestId = vestIds++;\n        _mint(vestParams.recipient, vestId);\n\n        vests[vestId] = Vest({\n            owner: msg.sender,\n            token: address(vestParams.token) == address(0)\n                ? IERC20(wETH)\n                : vestParams.token,\n            start: vestParams.start,\n            cliffDuration: vestParams.cliffDuration,\n            stepDuration: vestParams.stepDuration,\n            steps: vestParams.steps,\n            cliffShares: cliffShares,\n            stepShares: stepShares,\n            claimed: 0\n        });\n\n        emit CreateVesting(\n            vestId,\n            vestParams.token,\n            msg.sender,\n            vestParams.recipient,\n            vestParams.start,\n            vestParams.cliffDuration,\n            vestParams.stepDuration,\n            vestParams.steps,\n            cliffShares,\n            stepShares,\n            vestParams.fromBentoBox\n        );\n    }\n\n    function withdraw(\n        uint256 vestId,\n        bytes calldata taskData,\n        bool toBentoBox\n    ) external override {\n        Vest storage vest = vests[vestId];\n        address recipient = ownerOf[vestId];\n        if (recipient != msg.sender) revert NotVestReceiver();\n        uint256 canClaim = _balanceOf(vest) - vest.claimed;\n\n        if (canClaim == 0) return;\n\n        vest.claimed += uint128(canClaim);\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            recipient,\n            canClaim,\n            toBentoBox\n        );\n\n        if (taskData.length != 0) ITasker(recipient).onTaskReceived(taskData);\n\n        emit Withdraw(vestId, vest.token, canClaim, toBentoBox);\n    }\n\n    function stopVesting(uint256 vestId, bool toBentoBox) external override {\n        Vest memory vest = vests[vestId];\n\n        if (vest.owner != msg.sender) revert NotOwner();\n\n        uint256 amountVested = _balanceOf(vest);\n        uint256 canClaim = amountVested - vest.claimed;\n        uint256 returnShares = (vest.cliffShares +\n            (vest.steps * vest.stepShares)) - amountVested;\n\n        delete vests[vestId];\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            ownerOf[vestId],\n            canClaim,\n            toBentoBox\n        );\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            msg.sender,\n            returnShares,\n            toBentoBox\n        );\n        emit CancelVesting(\n            vestId,\n            returnShares,\n            canClaim,\n            vest.token,\n            toBentoBox\n        );\n    }\n\n    function vestBalance(uint256 vestId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Vest memory vest = vests[vestId];\n        return _balanceOf(vest) - vest.claimed;\n    }\n\n    function _balanceOf(Vest memory vest)\n        internal\n        view\n        returns (uint256 claimable)\n    {\n        uint256 timeAfterCliff = vest.start + vest.cliffDuration;\n\n        if (block.timestamp < timeAfterCliff) {\n            return claimable;\n        }\n\n        uint256 passedSinceCliff = block.timestamp - timeAfterCliff;\n\n        uint256 stepPassed = Math.min(\n            vest.steps,\n            passedSinceCliff / vest.stepDuration\n        );\n\n        claimable = vest.cliffShares + (vest.stepShares * stepPassed);\n    }\n\n    function updateOwner(uint256 vestId, address newOwner) external override {\n        Vest storage vest = vests[vestId];\n        if (vest.owner != msg.sender) revert NotOwner();\n        vest.owner = newOwner;\n        emit LogUpdateOwner(vestId, newOwner);\n    }\n\n    function _depositToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bool fromBentoBox\n    ) internal returns (uint256 depositedShares) {\n        if (fromBentoBox) {\n            depositedShares = bentoBox.toShare(token, amount, false);\n            bentoBox.transfer(token, from, to, depositedShares);\n        } else {\n            (, depositedShares) = bentoBox.deposit{\n                value: token == address(0) ? amount : 0\n            }(token, from, to, amount, 0);\n        }\n    }\n\n    function _transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 shares,\n        bool toBentoBox\n    ) internal {\n        if (toBentoBox) {\n            bentoBox.transfer(token, from, to, shares);\n        } else {\n            bentoBox.withdraw(token, from, to, 0, shares);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}