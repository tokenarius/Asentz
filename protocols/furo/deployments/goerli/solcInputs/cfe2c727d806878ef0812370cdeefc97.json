{
  "language": "Solidity",
  "sources": {
    "contracts/base/FuroStream.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IFuroStream.sol\";\n\n\n// Use the FuroStreamRouter to create Streams and do not create streams directly.\n\ncontract FuroStream is\n    IFuroStream,\n    ERC721(\"Furo Stream\", \"FUROSTREAM\"),\n    Multicall,\n    BoringOwnable\n{\n    IBentoBoxMinimal public immutable bentoBox;\n    address public immutable wETH;\n\n    uint256 public streamIds;\n\n    address public tokenURIFetcher;\n\n    mapping(uint256 => Stream) public streams;\n\n    // custom errors\n    error NotSenderOrRecipient();\n    error InvalidStartTime();\n    error InvalidEndTime();\n    error InvalidWithdrawTooMuch();\n    error NotSender();\n    error Overflow();\n\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\n        bentoBox = _bentoBox;\n        wETH = _wETH;\n        streamIds = 1000;\n        _bentoBox.registerProtocol();\n    }\n\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\n        tokenURIFetcher = _fetcher;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\n    }\n\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        bentoBox.setMasterContractApproval(\n            user,\n            address(this),\n            approved,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createStream(\n        address recipient,\n        address token,\n        uint64 startTime,\n        uint64 endTime,\n        uint256 amount, /// @dev in token amount and not in shares\n        bool fromBentoBox\n    )\n        external\n        payable\n        override\n        returns (uint256 streamId, uint256 depositedShares)\n    {\n        if (startTime < block.timestamp) revert InvalidStartTime();\n        if (endTime <= startTime) revert InvalidEndTime();\n\n        depositedShares = _depositToken(\n            token,\n            msg.sender,\n            address(this),\n            amount,\n            fromBentoBox\n        );\n\n        streamId = streamIds++;\n\n        _mint(recipient, streamId);\n\n        streams[streamId] = Stream({\n            sender: msg.sender,\n            token: token == address(0) ? wETH : token,\n            depositedShares: uint128(depositedShares), // @dev safe since we know bento returns u128\n            withdrawnShares: 0,\n            startTime: startTime,\n            endTime: endTime\n        });\n\n        emit CreateStream(\n            streamId,\n            msg.sender,\n            recipient,\n            token,\n            depositedShares,\n            startTime,\n            endTime,\n            fromBentoBox\n        );\n    }\n\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 sharesToWithdraw,\n        address withdrawTo,\n        bool toBentoBox,\n        bytes calldata taskData\n    ) external override returns (uint256 recipientBalance, address to) {\n        address recipient = ownerOf[streamId];\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\n            revert NotSenderOrRecipient();\n        }\n        Stream storage stream = streams[streamId];\n        (, recipientBalance) = _streamBalanceOf(stream);\n        if (recipientBalance < sharesToWithdraw)\n            revert InvalidWithdrawTooMuch();\n        stream.withdrawnShares += uint128(sharesToWithdraw);\n\n        if (msg.sender == recipient && withdrawTo != address(0)) {\n            to = withdrawTo;\n        } else {\n            to = recipient;\n        }\n\n        _transferToken(\n            stream.token,\n            address(this),\n            to,\n            sharesToWithdraw,\n            toBentoBox\n        );\n\n        if (taskData.length != 0 && msg.sender == recipient)\n            ITasker(to).onTaskReceived(taskData);\n\n        emit Withdraw(\n            streamId,\n            sharesToWithdraw,\n            withdrawTo,\n            stream.token,\n            toBentoBox\n        );\n    }\n\n    function cancelStream(uint256 streamId, bool toBentoBox)\n        external\n        override\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        address recipient = ownerOf[streamId];\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\n            revert NotSenderOrRecipient();\n        }\n        Stream memory stream = streams[streamId];\n        (senderBalance, recipientBalance) = _streamBalanceOf(stream);\n\n        delete streams[streamId];\n\n        _transferToken(\n            stream.token,\n            address(this),\n            recipient,\n            recipientBalance,\n            toBentoBox\n        );\n        _transferToken(\n            stream.token,\n            address(this),\n            stream.sender,\n            senderBalance,\n            toBentoBox\n        );\n\n        emit CancelStream(\n            streamId,\n            senderBalance,\n            recipientBalance,\n            stream.token,\n            toBentoBox\n        );\n    }\n\n    function getStream(uint256 streamId)\n        external\n        view\n        override\n        returns (Stream memory)\n    {\n        return streams[streamId];\n    }\n\n    function streamBalanceOf(uint256 streamId)\n        external\n        view\n        override\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        return _streamBalanceOf(streams[streamId]);\n    }\n\n    function _streamBalanceOf(Stream memory stream)\n        internal\n        view\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        if (block.timestamp <= stream.startTime) {\n            senderBalance = stream.depositedShares;\n            recipientBalance = 0;\n        } else if (stream.endTime <= block.timestamp) {\n            recipientBalance = stream.depositedShares - stream.withdrawnShares;\n            senderBalance = 0;\n        } else {\n            uint64 timeDelta = uint64(block.timestamp) - stream.startTime;\n            uint128 streamed = ((stream.depositedShares * timeDelta) /\n                (stream.endTime - stream.startTime));\n            recipientBalance = streamed - stream.withdrawnShares;\n            senderBalance = stream.depositedShares - streamed;\n        }\n    }\n\n    function updateSender(uint256 streamId, address sender) external override {\n        Stream storage stream = streams[streamId];\n        if (msg.sender != stream.sender) revert NotSender();\n        stream.sender = sender;\n    }\n\n    function updateStream(\n        uint256 streamId,\n        uint128 topUpAmount,\n        uint64 extendTime,\n        bool fromBentoBox\n    ) external payable override returns (uint256 depositedShares) {\n        Stream storage stream = streams[streamId];\n        if (msg.sender != stream.sender) revert NotSender();\n\n        depositedShares = _depositToken(\n            stream.token,\n            stream.sender,\n            address(this),\n            topUpAmount,\n            fromBentoBox\n        );\n\n        address recipient = ownerOf[streamId];\n\n        (uint256 senderBalance, uint256 recipientBalance) = _streamBalanceOf(\n            stream\n        );\n\n        stream.startTime = uint64(block.timestamp);\n        stream.withdrawnShares = 0;\n        uint256 newDepositedShares = senderBalance + depositedShares;\n        if (newDepositedShares > type(uint128).max) revert Overflow();\n        stream.depositedShares = uint128(newDepositedShares);\n        stream.endTime += extendTime;\n\n        _transferToken(\n            stream.token,\n            address(this),\n            recipient,\n            recipientBalance,\n            true\n        );\n\n        emit UpdateStream(streamId, topUpAmount, extendTime, fromBentoBox);\n    }\n\n    function _depositToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bool fromBentoBox\n    ) internal returns (uint256 depositedShares) {\n        if (fromBentoBox) {\n            depositedShares = bentoBox.toShare(token, amount, false);\n            bentoBox.transfer(token, from, to, depositedShares);\n        } else {\n            (, depositedShares) = bentoBox.deposit{\n                value: token == address(0) ? amount : 0\n            }(token, from, to, amount, 0);\n        }\n    }\n\n    function _transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 share,\n        bool toBentoBox\n    ) internal {\n        if (toBentoBox) {\n            bentoBox.transfer(token, from, to, share);\n        } else {\n            bentoBox.withdraw(token, from, to, 0, share);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IFuroStream.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"./ITasker.sol\";\nimport \"./ITokenURIFetcher.sol\";\nimport \"./IBentoBoxMinimal.sol\";\nimport \"../utils/Multicall.sol\";\nimport \"../utils/BoringOwnable.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ninterface IFuroStream {\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    function createStream(\n        address recipient,\n        address token,\n        uint64 startTime,\n        uint64 endTime,\n        uint256 amount, /// @dev in token amount and not in shares\n        bool fromBento\n    ) external payable returns (uint256 streamId, uint256 depositedShares);\n\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 sharesToWithdraw,\n        address withdrawTo,\n        bool toBentoBox,\n        bytes memory taskData\n    ) external returns (uint256 recipientBalance, address to);\n\n    function cancelStream(uint256 streamId, bool toBentoBox)\n        external\n        returns (uint256 senderBalance, uint256 recipientBalance);\n\n    function updateSender(uint256 streamId, address sender) external;\n\n    function updateStream(\n        uint256 streamId,\n        uint128 topUpAmount,\n        uint64 extendTime,\n        bool fromBentoBox\n    ) external payable returns (uint256 depositedShares);\n\n    function streamBalanceOf(uint256 streamId)\n        external\n        view\n        returns (uint256 senderBalance, uint256 recipientBalance);\n\n    function getStream(uint256 streamId) external view returns (Stream memory);\n\n    event CreateStream(\n        uint256 indexed streamId,\n        address indexed sender,\n        address indexed recipient,\n        address token,\n        uint256 amount,\n        uint256 startTime,\n        uint256 endTime,\n        bool fromBentoBox\n    );\n\n    event UpdateStream(\n        uint256 indexed streamId,\n        uint128 indexed topUpAmount,\n        uint64 indexed extendTime,\n        bool fromBentoBox\n    );\n\n    event Withdraw(\n        uint256 indexed streamId,\n        uint256 indexed sharesToWithdraw,\n        address indexed withdrawTo,\n        address token,\n        bool toBentoBox\n    );\n\n    event CancelStream(\n        uint256 indexed streamId,\n        uint256 indexed senderBalance,\n        uint256 indexed recipientBalance,\n        address token,\n        bool toBentoBox\n    );\n\n    struct Stream {\n        address sender;\n        address token;\n        uint128 depositedShares;\n        uint128 withdrawnShares;\n        uint64 startTime;\n        uint64 endTime;\n    }\n}\n"
    },
    "contracts/interfaces/ITasker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\ninterface ITasker {\n    function onTaskReceived(\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITokenURIFetcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\ninterface ITokenURIFetcher {\n    function fetchTokenURIData(uint256 id)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/interfaces/IBentoBoxMinimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token_ The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall {\n    function multicall(bytes[] calldata data)\n        public\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}"
    },
    "contracts/utils/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(\n                newOwner != address(0) || renounce,\n                \"Ownable: zero address\"\n            );\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(\n            msg.sender == _pendingOwner,\n            \"Ownable: caller != pending owner\"\n        );\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/FuroStreamRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport './interfaces/IFuroStream.sol';\n\ncontract FuroStreamRouter is Multicall {\n  IBentoBoxMinimal public immutable bentoBox;\n  IFuroStream public immutable furoStream;\n  address public immutable wETH;\n\n  // custom errors\n  error InsufficientShares();\n\n  constructor(\n    IBentoBoxMinimal _bentoBox,\n    IFuroStream _furoStream,\n    address _wETH\n  ) {\n    bentoBox = _bentoBox;\n    furoStream = _furoStream;\n    wETH = _wETH;\n    _bentoBox.setMasterContractApproval(address(this), address(_furoStream), true, 0, bytes32(0), bytes32(0));\n    _bentoBox.registerProtocol();\n  }\n\n  function setBentoBoxApproval(\n    address user,\n    bool approved,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable {\n    bentoBox.setMasterContractApproval(user, address(this), approved, v, r, s);\n  }\n\n  function createStream(\n    address recipient,\n    address token,\n    uint64 startTime,\n    uint64 endTime,\n    uint256 amount, /// @dev in token amount and not in shares\n    bool fromBentoBox,\n    uint256 minShare\n  ) external payable returns (uint256 streamId, uint256 depositedShares) {\n    depositedShares = _depositToken(token, msg.sender, address(this), amount, fromBentoBox);\n\n    if (depositedShares < minShare) revert InsufficientShares();\n\n    (streamId, ) = furoStream.createStream(\n      recipient,\n      token == address(0) ? wETH : token,\n      startTime,\n      endTime,\n      amount,\n      true\n    );\n\n    furoStream.updateSender(streamId, msg.sender);\n  }\n\n  function _depositToken(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bool fromBentoBox\n  ) internal returns (uint256 depositedShares) {\n    if (fromBentoBox) {\n      depositedShares = bentoBox.toShare(token, amount, false);\n      bentoBox.transfer(token, from, to, depositedShares);\n    } else {\n      (, depositedShares) = bentoBox.deposit{value: token == address(0) ? amount : 0}(token, from, to, amount, 0);\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IFuroVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"./ITasker.sol\";\nimport \"./IERC20.sol\";\nimport \"./ITokenURIFetcher.sol\";\nimport \"./IBentoBoxMinimal.sol\";\nimport \"../utils/Multicall.sol\";\nimport \"../utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ninterface IFuroVesting {\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    function createVesting(VestParams calldata vestParams)\n        external\n        payable\n        returns (\n            uint256 depositedShares,\n            uint256 vestId,\n            uint128 stepShares,\n            uint128 cliffShares\n        );\n\n    function withdraw(\n        uint256 vestId,\n        bytes memory taskData,\n        bool toBentoBox\n    ) external;\n\n    function stopVesting(uint256 vestId, bool toBentoBox) external;\n\n    function vestBalance(uint256 vestId) external view returns (uint256);\n\n    function updateOwner(uint256 vestId, address newOwner) external;\n\n    struct VestParams {\n        IERC20 token;\n        address recipient;\n        uint32 start;\n        uint32 cliffDuration;\n        uint32 stepDuration;\n        uint32 steps;\n        uint128 stepPercentage;\n        uint128 amount;\n        bool fromBentoBox;\n    }\n\n    struct Vest {\n        address owner;\n        IERC20 token;\n        uint32 start;\n        uint32 cliffDuration;\n        uint32 stepDuration;\n        uint32 steps;\n        uint128 cliffShares;\n        uint128 stepShares;\n        uint128 claimed;\n    }\n\n    event CreateVesting(\n        uint256 indexed vestId,\n        IERC20 token,\n        address indexed owner,\n        address indexed recipient,\n        uint32 start,\n        uint32 cliffDuration,\n        uint32 stepDuration,\n        uint32 steps,\n        uint128 cliffShares,\n        uint128 stepShares,\n        bool fromBentoBox\n    );\n\n    event Withdraw(\n        uint256 indexed vestId,\n        IERC20 indexed token,\n        uint256 indexed amount,\n        bool toBentoBox\n    );\n\n    event CancelVesting(\n        uint256 indexed vestId,\n        uint256 indexed ownerAmount,\n        uint256 indexed recipientAmount,\n        IERC20 token,\n        bool toBentoBox\n    );\n\n    event LogUpdateOwner(uint256 indexed vestId, address indexed newOwner);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/FuroVestingRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport './interfaces/IFuroVesting.sol';\n\ncontract FuroVestingRouter is Multicall {\n  IBentoBoxMinimal public immutable bentoBox;\n  IFuroVesting public immutable furoVesting;\n  address public immutable wETH;\n\n  // custom errors\n  error InsufficientShares();\n\n  constructor(\n    IBentoBoxMinimal _bentoBox,\n    IFuroVesting _furoVesting,\n    address _wETH\n  ) {\n    bentoBox = _bentoBox;\n    furoVesting = _furoVesting;\n    wETH = _wETH;\n    _bentoBox.setMasterContractApproval(address(this), address(_furoVesting), true, 0, bytes32(0), bytes32(0));\n    _bentoBox.registerProtocol();\n  }\n\n  function setBentoBoxApproval(\n    address user,\n    bool approved,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable {\n    bentoBox.setMasterContractApproval(user, address(this), approved, v, r, s);\n  }\n\n  function createVesting(IFuroVesting.VestParams memory vestParams, uint256 minShare)\n    external\n    payable\n    returns (\n      uint256 depositedShares,\n      uint256 vestId,\n      uint128 stepShares,\n      uint128 cliffShares\n    )\n  {\n    depositedShares = _depositToken(\n      address(vestParams.token),\n      msg.sender,\n      address(this),\n      vestParams.amount,\n      vestParams.fromBentoBox\n    );\n\n    if (depositedShares < minShare) revert InsufficientShares();\n\n    if (address(vestParams.token) == address(0)) {\n      vestParams.token = IERC20(wETH);\n    }\n    vestParams.fromBentoBox = true;\n\n    (depositedShares, vestId, stepShares, cliffShares) = furoVesting.createVesting(vestParams);\n\n    furoVesting.updateOwner(vestId, msg.sender);\n  }\n\n  function _depositToken(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bool fromBentoBox\n  ) internal returns (uint256 depositedShares) {\n    if (fromBentoBox) {\n      depositedShares = bentoBox.toShare(token, amount, false);\n      bentoBox.transfer(token, from, to, depositedShares);\n    } else {\n      (, depositedShares) = bentoBox.deposit{value: token == address(0) ? amount : 0}(token, from, to, amount, 0);\n    }\n  }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x95d89b41)\n        );\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x06fdde03)\n        );\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeDecimals(IERC20 token) public view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x313ce567)\n        );\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: Transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TransferFrom failed\"\n        );\n    }\n}\n"
    },
    "contracts/mock/TaskReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/ITasker.sol\";\n\ncontract TaskReceiverMock is ITasker {\n\n    function onTaskReceived(bytes memory taskData) external override {\n        \n    }\n\n}"
    },
    "contracts/base/FuroVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IFuroVesting.sol\";\n\n// Use the FuroStreamVesting to create Vesting and do not create vesting directly.\n\n\ncontract FuroVesting is\n    IFuroVesting,\n    ERC721(\"Furo Vesting\", \"FUROVEST\"),\n    Multicall,\n    BoringOwnable\n{\n    IBentoBoxMinimal public immutable bentoBox;\n    address public immutable wETH;\n\n    address public tokenURIFetcher;\n\n    mapping(uint256 => Vest) public vests;\n\n    uint256 public vestIds;\n\n    uint256 public constant PERCENTAGE_PRECISION = 1e18;\n\n    // custom errors\n    error InvalidStart();\n    error NotOwner();\n    error NotVestReceiver();\n    error InvalidStepSetting();\n\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\n        bentoBox = _bentoBox;\n        wETH = _wETH;\n        vestIds = 1;\n        _bentoBox.registerProtocol();\n    }\n\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\n        tokenURIFetcher = _fetcher;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\n    }\n\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        bentoBox.setMasterContractApproval(\n            user,\n            address(this),\n            approved,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createVesting(VestParams calldata vestParams)\n        external\n        payable\n        override\n        returns (\n            uint256 depositedShares,\n            uint256 vestId,\n            uint128 stepShares,\n            uint128 cliffShares\n        )\n    {\n        if (vestParams.start < block.timestamp) revert InvalidStart();\n        if (vestParams.stepPercentage > PERCENTAGE_PRECISION)\n            revert InvalidStepSetting();\n        if (vestParams.stepDuration == 0 || vestParams.steps == 0)\n            revert InvalidStepSetting();\n\n        depositedShares = _depositToken(\n            address(vestParams.token),\n            msg.sender,\n            address(this),\n            vestParams.amount,\n            vestParams.fromBentoBox\n        );\n        stepShares = uint128(\n            (vestParams.stepPercentage * depositedShares) / PERCENTAGE_PRECISION\n        );\n        cliffShares = uint128(\n            depositedShares - (stepShares * vestParams.steps)\n        );\n\n        vestId = vestIds++;\n        _mint(vestParams.recipient, vestId);\n\n        vests[vestId] = Vest({\n            owner: msg.sender,\n            token: address(vestParams.token) == address(0)\n                ? IERC20(wETH)\n                : vestParams.token,\n            start: vestParams.start,\n            cliffDuration: vestParams.cliffDuration,\n            stepDuration: vestParams.stepDuration,\n            steps: vestParams.steps,\n            cliffShares: cliffShares,\n            stepShares: stepShares,\n            claimed: 0\n        });\n\n        emit CreateVesting(\n            vestId,\n            vestParams.token,\n            msg.sender,\n            vestParams.recipient,\n            vestParams.start,\n            vestParams.cliffDuration,\n            vestParams.stepDuration,\n            vestParams.steps,\n            cliffShares,\n            stepShares,\n            vestParams.fromBentoBox\n        );\n    }\n\n    function withdraw(\n        uint256 vestId,\n        bytes calldata taskData,\n        bool toBentoBox\n    ) external override {\n        Vest storage vest = vests[vestId];\n        address recipient = ownerOf[vestId];\n        if (recipient != msg.sender) revert NotVestReceiver();\n        uint256 canClaim = _balanceOf(vest) - vest.claimed;\n\n        if (canClaim == 0) return;\n\n        vest.claimed += uint128(canClaim);\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            recipient,\n            canClaim,\n            toBentoBox\n        );\n\n        if (taskData.length != 0) ITasker(recipient).onTaskReceived(taskData);\n\n        emit Withdraw(vestId, vest.token, canClaim, toBentoBox);\n    }\n\n    function stopVesting(uint256 vestId, bool toBentoBox) external override {\n        Vest memory vest = vests[vestId];\n\n        if (vest.owner != msg.sender) revert NotOwner();\n\n        uint256 amountVested = _balanceOf(vest);\n        uint256 canClaim = amountVested - vest.claimed;\n        uint256 returnShares = (vest.cliffShares +\n            (vest.steps * vest.stepShares)) - amountVested;\n\n        delete vests[vestId];\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            ownerOf[vestId],\n            canClaim,\n            toBentoBox\n        );\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            msg.sender,\n            returnShares,\n            toBentoBox\n        );\n        emit CancelVesting(\n            vestId,\n            returnShares,\n            canClaim,\n            vest.token,\n            toBentoBox\n        );\n    }\n\n    function vestBalance(uint256 vestId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Vest memory vest = vests[vestId];\n        return _balanceOf(vest) - vest.claimed;\n    }\n\n    function _balanceOf(Vest memory vest)\n        internal\n        view\n        returns (uint256 claimable)\n    {\n        uint256 timeAfterCliff = vest.start + vest.cliffDuration;\n\n        if (block.timestamp < timeAfterCliff) {\n            return claimable;\n        }\n\n        uint256 passedSinceCliff = block.timestamp - timeAfterCliff;\n\n        uint256 stepPassed = Math.min(\n            vest.steps,\n            passedSinceCliff / vest.stepDuration\n        );\n\n        claimable = vest.cliffShares + (vest.stepShares * stepPassed);\n    }\n\n    function updateOwner(uint256 vestId, address newOwner) external override {\n        Vest storage vest = vests[vestId];\n        if (vest.owner != msg.sender) revert NotOwner();\n        vest.owner = newOwner;\n        emit LogUpdateOwner(vestId, newOwner);\n    }\n\n    function _depositToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bool fromBentoBox\n    ) internal returns (uint256 depositedShares) {\n        if (fromBentoBox) {\n            depositedShares = bentoBox.toShare(token, amount, false);\n            bentoBox.transfer(token, from, to, depositedShares);\n        } else {\n            (, depositedShares) = bentoBox.deposit{\n                value: token == address(0) ? amount : 0\n            }(token, from, to, amount, 0);\n        }\n    }\n\n    function _transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 shares,\n        bool toBentoBox\n    ) internal {\n        if (toBentoBox) {\n            bentoBox.transfer(token, from, to, shares);\n        } else {\n            bentoBox.withdraw(token, from, to, 0, shares);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}